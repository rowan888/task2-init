/******** DO NOT EDIT THIS FILE ********/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>
#include "rft_client_logging.h"

/* "private/static" function declarations */

/* output standard header to stream */
static void log_header(FILE* stream, protocol_t* proto);

/* output for normal states */
static void log_init(protocol_t* proto);
static void log_data_send(protocol_t* proto);
static void log_tfr_ready(protocol_t* proto);
static void log_start_send(protocol_t* proto);
static void log_no_ack(protocol_t* proto);
static void log_ack_wait(protocol_t* proto);
static void log_ack_recv(protocol_t* proto);
static void log_tfr_complete(protocol_t* proto);
static void log_empty_file(protocol_t* proto);
/* output for error states */
static void bad_ack_sq_err(protocol_t* proto);
static void exceed_retry_err(protocol_t* proto);
static void log_err(protocol_t* proto);
static void bad_log(protocol_t* proto);

/* array of output function pointers indexed by non-error protocol state */
static void (*log_protocol_state[])(protocol_t*) = {
    log_init,           //  0 - PS_INIT
    log_data_send,      //  1 - PS_DATA_RESEND
    log_tfr_ready,      //  2 - PS_TFR_READY
    log_no_ack,         //  3 - PS_NO_ACK
    log_start_send,     //  4 - PS_START_SEND
    NULL,               //  5 - undefined
    log_data_send,      //  6 - PS_DATA_SEND
    NULL,               //  7 - undefined
    log_ack_wait,       //  8 - PS_ACK_WAIT
    NULL,               //  9 - undefined
    log_ack_recv,       // 10 - PS_ACK_RECV
    NULL,               // 11 - undefined
    log_tfr_complete,   // 12 - PS_TFR_COMPLETE
    NULL,               // 13 - undefined
    log_empty_file,     // 14 - PS_EMPTY_FILE
    NULL,               // 15 - undefined
    log_err,            // 16 - PS_BAD_READ
    NULL,               // 17 - undefined
    log_err,            // 18 - PS_BAD_SEND
    NULL,               // 19 - undefined
    log_err,            // 20 - PS_BAD_ACK
    NULL,               // 21 - undefined
    bad_ack_sq_err,     // 22 - PS_BAD_ACK_SQ
    NULL,               // 23 - undefined
    log_err,            // 24 - PS_BAD_S_SIZE
    NULL,               // 25 - undefined
    log_err,            // 26 - PS_BAD_S_FAM
    NULL,               // 27 - undefined
    log_err,            // 28 - PS_BAD_S_PORT
    NULL,               // 29 - undefined
    log_err,            // 30 - PS_BAD_S_ADDR
    NULL,               // 31 - undefined
    exceed_retry_err,   // 32 - PS_EXCEED_RETRY
    NULL,               // 33 - undefined
    log_err,            // 34 - PS_BAD_SOCK_TO
    bad_log             // 34 - PS_BAD_LOG
};

/* array of state strings for output indexed by protocol state */
static char* state_str[] = {
    "PS_INIT",          //  0 - PS_INIT
    "PS_DATA_RESEND",   //  1 - PS_DATA_RESEND
    "PS_TFR_READY",     //  2 - PS_TFR_READY
    "PS_NO_ACK",        //  3 - PS_NO_ACK
    "PS_START_SEND",    //  4 - PS_START_SEND
    NULL,               //  5 - undefined
    "PS_DATA_SEND",     //  6 - PS_DATA_SEND
    NULL,               //  7 - undefined
    "PS_ACK_WAIT",      //  8 - PS_ACK_WAIT
    NULL,               //  9 - undefined
    "PS_ACK_RECV",      // 10 - PS_ACK_RECV
    NULL,               // 11 - undefined
    "PS_TFR_COMPLETE",  // 12 - PS_TFR_COMPLETE
    NULL,               // 13 - undefined
    "PS_EMPTY_FILE",    // 14 - PS_EMPTY_FILE
    NULL,               // 15 - undefined
    "PS_BAD_READ",      // 16 - PS_BAD_READ
    NULL,               // 17 - undefined
    "PS_BAD_SEND",      // 18 - PS_BAD_SEND
    NULL,               // 19 - undefined
    "PS_BAD_ACK",       // 20 - PS_BAD_ACK
    NULL,               // 21 - undefined
    "PS_BAD_ACK_SQ",    // 22 - PS_BAD_ACK_SQ
    NULL,               // 23 - undefined
    "PS_BAD_S_SIZE",    // 24 - PS_BAD_S_SIZE
    NULL,               // 25 - undefined
    "PS_BAD_S_FAM",     // 26 - PS_BAD_S_FAM
    NULL,               // 27 - undefined
    "PS_BAD_S_PORT",    // 28 - PS_BAD_S_PORT
    NULL,               // 29 - undefined
    "PS_BAD_S_ADDR",    // 30 - PS_BAD_S_ADDR
    NULL,               // 31 - undefined
    "PS_EXCEED_RETRY",  // 32 - PS_EXCEED_RETRY
    NULL,               // 33 - undefined
    "PS_BAD_SOCKTOUT",  // 34 - PS_BAD_SOCKTOUT
    NULL,               // 35 - undefined
    "PS_BAD_LOG"        // 36 - PS_BAD_LOG
};

/* array of error message strings for output indexed by error states 
 * (starting at PS_BAD_READ) 
 */
static char* err_msg[] = {
    "Error reading the input file",     // index: PS_BAD_READ - PS_BAD_READ
    NULL,
    "Error in send (bytes sent do not match segment size)",
                                        // index: PS_BAD_SEND - PS_BAD_READ
    NULL,
    "ACK size does not match segment size",
                                        // index: PS_BAD_ACK - PS_BAD_READ
    NULL,
    NULL,                               // index: PS_BAD_ACK_SQ - PS_BAD_READ
    NULL,
    "ACK server address structure size is incorrect",
                                        // index: PS_BAD_S_SIZE - PS_BAD_READ
    NULL,
    "ACK server family does not match",
                                        // index: PS_BAD_S_FAM - PS_BAD_READ
    NULL,
    "ACK server port does not match",
                                        // index: PS_BAD_S_PORT - PS_BAD_READ
    NULL,
    "ACK server addr does not match",
                                        // index: PS_BAD_S_ADDR - PS_BAD_READ
    NULL,
    NULL,                               // index: PS_EXCEED_RETRY - PS_BAD_READ
    NULL,                               
    "Could not set the socket timeout", // index: PS_BAD_SOCKTOUT - PS_BAD_READ
    NULL,                               
    NULL                                // index: PS_BAD_LOG - PS_BAD_READ
};
    


/* implementation of "public" functions declared in rft_client_logging.h */

void exit_err(protocol_t* proto) {
    if (proto->in_file) fclose(proto->in_file);
    if (proto->sockfd != -1) close(proto->sockfd);
    
    log_header(stderr, proto);
    
    fprintf(stderr, "ERROR: ");
    
    if (proto->state < PS_BAD_READ) {
        log_err(proto);
    } else {
        proto->err_msg = err_msg[proto->state - PS_BAD_READ];
        log_protocol_state[proto->state](proto);
    }

    fprint_sep(stderr);

    exit(EXIT_FAILURE);
}

void exit_err_msg(protocol_t* proto, int init_errno, int line, 
    char* msg) {
    errno = init_errno;
    proto->src_line = line;
    proto->err_msg = msg;
    exit_err(proto);
}

void exit_err_state(protocol_t* proto, proto_state state, int line) {
    proto->state = state;
    proto->src_line = line;
    exit_err(proto);
}

void log_protocol(protocol_t* proto) {
    if (!proto->src_file || !proto->src_file[0] || proto->src_line < 1) {
        proto->state = PS_BAD_LOG;
        exit_err(proto);
    }
        
    log_header(stdout, proto);
    
    log_protocol_state[proto->state](proto);

    print_sep();
    
    proto->src_line = 0;
}    

void print_sep() {
    fprint_sep(stdout);
}

void fprint_sep(FILE* stream) {
    fprintf(stream, 
            "----------------------------------------------------------"
            "---------------------\n");
}

/* implementation of "private/static" functions */

static void bad_ack_sq_err(protocol_t* proto) {
    fprintf(stderr,
        "ACK sequence number %d does not match data sequence number %d\n",
        proto->ack.sq, proto->data.sq);
}

static void exceed_retry_err(protocol_t* proto) {
    fprintf(stderr,
        "Consecutive retry limit exceeded, max_retries: %d, curr_retry: %d\n",
        proto->max_retries, proto->curr_retry);
}

static void log_err(protocol_t* proto) {
    if (errno) {
        fprintf(stderr, "[%s]\n%s\n", strerror(errno), proto->err_msg);
    } else {
        fprintf(stderr, "%s\n", proto->err_msg);
    }    
}

static void bad_log(protocol_t* proto) {
    proto->src_file = NULL;
    if (!proto->src_file || !proto->src_file[0]) 
        fprintf(stderr, "%s",
            "Protocol source file is NULL.\n"
            "It should be set to the __FILE__ that "
            "contains the log statement\n");

    if (proto->src_line < 1) 
        fprintf(stderr,
            "Protocol source file line is not set or is invalid.\n"
            "It is: %d. It should be the __LINE__ where the log statement "
            "appears\n", proto->src_line);
}

static void log_header(FILE* stream, protocol_t* proto) {
    fprint_sep(stream);
    fprintf(stream, "CLIENT [%s:%d:state:%s]\n", 
        proto->src_file, proto->src_line, state_str[proto->state]);
}

static void log_init(protocol_t* proto) {
    printf("Initialised for %s transfer of file: %s to file: %s\n"
        "on server: %s:%d with loss probality: %f\n", proto->tfr_mode, 
        proto->in_fname, proto->out_fname, proto->server_addr, 
        proto->server_port, proto->loss_prob);
}

static void log_tfr_ready(protocol_t* proto) {
    printf("Opened file: %s (%zd bytes), socket and server set.\n",
        proto->in_fname, (long) proto->fsize);
    printf("Client ready for transfer\n");
}

static void log_start_send(protocol_t* proto) {
    printf("Start sending file in %s mode\n", proto->tfr_mode);
}

static void log_data_send(protocol_t* proto) {
    static char* prefix[] = { "Sending", "Resending", };
    printf("%s segment with sq: %d, file data: %zd, "
        "checksum: %d\ncurrent retry: %d, max retries allowed: %d\n", 
        prefix[proto->state % 2], proto->data.sq, proto->data.file_data, 
        proto->data.checksum, proto->curr_retry, proto->max_retries);

    if (proto->data.payload[0])
        printf("payload:\n%s\n", proto->data.payload);
}

static void log_ack_wait(protocol_t* proto) {
    printf("Waiting for an ACK\n");
}

static void log_ack_recv(protocol_t* proto) { 
    printf("ACK with sq: %d received\n", proto->ack.sq);
        
    if (proto->ack.sq != proto->data.sq) {
        printf("but != data.sq: %d\n", proto->data.sq);
    }
}

static void log_no_ack(protocol_t* proto) { 
    printf(">>>> ACK timeout for segment with sq: %d <<<<\n", proto->data.sq);
}

static void log_tfr_complete(protocol_t* proto) {
    printf("Transfer complete\n");
    printf("Total segments sent: %d, including: %d resends\n", 
        proto->total_segments, proto->resent_segments);
    printf("%zd bytes sent for transfer of file: %s of size: %zd\n",
        proto->total_file_data, proto->in_fname, (long) proto->fsize);
}

static void log_empty_file(protocol_t* proto) {
    printf("Input file: %s is empty (0 bytes)\n", proto->in_fname); 
    printf("No further data sent after sending metadata. "
            "Protocol terminated\n");
}

